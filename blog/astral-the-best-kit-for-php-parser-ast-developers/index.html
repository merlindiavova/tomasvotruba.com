<!DOCTYPE html>
<html lang="en">
    <head>
        <title>Astral - The Best Kit for php-parser AST Developers | Tomas Votruba</title>
<meta charset="utf-8">
<meta name="robots" content="index, follow">

<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

<meta name="mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-capable" content="yes">

<meta name="twitter:card" content="summary"/>
<meta name="twitter:creator" content="@votrubaT"/>

    <meta property="og:image" content="/assets/images/tomas_votruba.jpg"/>

    <meta name="twitter:image" content="/assets/images/tomas_votruba.jpg"/>

<link rel="alternate" type="application/rss+xml" title="Tomas Votruba Blog RSS" href="/rss.xml">


<link rel="stylesheet" rel="preload" as="style" href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:700&amp;display=swap" />

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/css/bootstrap.min.css" integrity="sha384-B0vP5xmATw1+K9KRQjQERJvTumQW0nPEzvF6L/Z6nronJ3oUOFUFpCjEUQouq2+l" crossorigin="anonymous" media="print" onload="this.media='all'">

<link href="/assets/css/style.css?693368684" rel="stylesheet" type="text/css" />

                <meta name="description" property="og:description" content="Working with php-parser abstract syntax tree is fun. You can modify [any node](https://github.com/rectorphp/php-parser-nodes-docs) in the tree, change class method names or add new arguments.

Such work requires **abstract and [deeply focused thinking](/blog/2018/09/13/your-brain-is-your-garden/)**. But sometimes, all we need is to get a method call name or constant value. That&#039;s completely different detailed nitpicking boring thinking...

That&#039;s where **Astral package helps**.
" />
    </head>

    <body>
        <!-- post_id: 308 -->
        <div id="menu">
    <div class="container-fluid">
        <a href="/">Home</a>
        <span class="pl-2 pr-2">•</span>

        <a href="/blog">Blog</a>
        <span class="pl-2 pr-2">•</span>

        <a href="/book/the-power-of-automated-refactoring">Book</a>
        <span class="pl-2 pr-2">•</span>

        <a href="/trainings">Trainings</a>
        <span class="pl-2 pr-2">•</span>

        <a href="/contact">Contact</a>
        <span class="pl-2 pr-2">•</span>

        <a href="/about-me">About Me</a>
        <span class="pl-2 pr-2">•</span>

        <a href="https://twitter.com/votrubaT" target="blank">Twitter</a>
        <span class="pl-2 pr-2">•</span>

        <a href="/rss.xml" target="blank">RSS</a>
    </div>
</div>

        <div class="container-fluid post" id="content">
            <div class="text-center book-banner">
                <a href="https://leanpub.com/rector-the-power-of-automated-refactoring" target="blank" class="text-center">
                    <img src="/assets/images/banner-rector-book.png" class="mb-2 ml-auto mr-auto rounded " style="max-height: 5em" alt="">
                </a>
            </div>

            <h1>Astral - The Best Kit for php-parser AST Developers</h1>

            <div class="pull-right">
                <a href="https://github.com/tomasvotruba/tomasvotruba.com/edit/main/packages/blog/data/2021/2021-03-22-astral-the-best-kit-for-php-parser-ast-developers.md">Found a typo? Edit me</a>
            </div>

            <time datetime="2021-03-Mon" class="text-muted">
                2021-03-22
            </time>

            
            
            <div class="card card-bigger mb-5">
                <div class="card-body pb-2">
                    <p>Working with php-parser abstract syntax tree is fun. You can modify <a href="https://github.com/rectorphp/php-parser-nodes-docs">any node</a> in the tree, change class method names or add new arguments.
<br><br>
Such work requires <strong>abstract and <a href="/blog/2018/09/13/your-brain-is-your-garden/">deeply focused thinking</a></strong>. But sometimes, all we need is to get a method call name or constant value. That's completely different detailed nitpicking boring thinking...
<br><br>
That's where <strong>Astral package helps</strong>.</p>
                </div>
            </div>

            <blockquote class="blockquote text-center mb-5">
    Keeping simple changes in code,<br>
    simple in AST as well.
</blockquote>
<h2 id="Supports-native-php-Rector-and-PHPStan">Supports native php, Rector and PHPStan</h2>
<p>The <a href="https://github.com/symplify/astral">Astral package</a> works for your php-parser code, Rector rules, and PHPStan rules too.</p>
<pre><code class="language-bash">composer require symplify/astral</code></pre>
<p><strong>A. For PHPStan</strong>, include the config in <code>phpstan.neon</code>:</p>
<pre><code class="language-yaml">includes:
    - vendor/symplify/astral/config/services.neon</code></pre>
<p>We use this package in <a href="/blog/2020/12/14/new-in-symplify-9-more-than-110-phpstan-rules/">symplify/phpstan-rules</a> quite extensively.</p>
<p><br></p>
<p><strong>B. For your own php-parser code or Rector rule</strong>, add Symfony container with Bundle:</p>
<pre><code class="language-php">// config/bundles.php
return [
    Symplify\Astral\Bundle\AstralBundle::class =&gt; ['all' =&gt; true],
];</code></pre>
<p>Now we have the package installed, so how can we use it in real code?</p>
<h2 id="1-Get-Node-Name">1. Get Node Name</h2>
<p>Let's say we have this input code we want to process with AST:</p>
<pre><code class="language-php">$someMethod-&gt;someCall(100);</code></pre>
<p>We want to:</p>
<ul>
<li>get the name of the method call</li>
<li>and argument value</li>
<li>change the value if it is lower than 50</li>
</ul>
<p><br></p>
<p>How can we get a node name in native php-parser? Usually, we have an input method that already passes the node we work with:</p>
<pre><code class="language-php">use PhpParser\Node\Expr;
use PhpParser\Node\Expr\MethodCall;
use PhpParser\Node\Expr\Variable;

final class SomeRule
{
    public function resolveNames(MethodCall $methodCall): array
    {
        if ($methodCall-&gt;name instanceof Expr) {
            return [];
        }

        $methodName = $methodCall-&gt;name-&gt;toString();

        if ($methodCall-&gt;var instanceof Variable) {
            return [];
        }

        /** @var Variable $methodCallVariable */
        $methodCallVariable = $methodCall-&gt;var;
        if (! $methodCallVariable-&gt;name instanceof Expr) {
            return [];
        }

        $methodCallerVariableName = (string) $methodCallVariable-&gt;name;

        return [$methodName, $methodCallerVariableName];
    }
}</code></pre>
<p>Good, now we have names of variable and the method name:</p>
<ul>
<li><code>$methodName</code> → <code>"someCall"</code></li>
<li><code>$methodCallerVariableName</code> → <code>"someMethod"</code></li>
</ul>
<p>We haven't even started to write our AST logic, but the code is already pretty complicated. Could we do any better?</p>
<p><br></p>
<p><strong>How does the same logic look with Astral?</strong></p>
<pre><code class="language-php">use PhpParser\Node\Expr\MethodCall;
use Symplify\Astral\Naming\SimpleNameResolver;

final class SomeRule
{
    public function __construct(
        // PHP 8.0 promoted property syntax
        private SimpleNameResolver $simpleNameResolver
    ) {
    }

    public function resolveNames(MethodCall $methodCall): array
    {
        $methodName = $this-&gt;simpleNameResolver-&gt;getName($methodCall-&gt;name);
        $methodCallerVariableName = $this-&gt;simpleNameResolver-&gt;getName($methodCall-&gt;var);

        return [$methodName, $methodCallerVariableName];
    }
}</code></pre>
<p>No boiler plate code, overly safe check for <code>Expr</code> or node type. The <code>getName()</code> just gets the name or <code>null</code> if it's not possible, e.g. for magical naming:</p>
<pre><code class="language-php">$someMethod-&gt;{$someMethodName}(100);</code></pre>
<p>Make use of other method that save you some work:</p>
<pre><code class="language-php">$this-&gt;simpleNameResolver-&gt;isName($node, 'someExpectedName');
$this-&gt;simpleNameResolver-&gt;isNames($node, ['assertTrue', 'assertFalse']);

// useful for PHPStan class name
$this-&gt;simpleNameResolver-&gt;getClassNameFromScope($scope);</code></pre>
<p>And so on.</p>
<h2 id="2-Get-Node-Value">2. Get Node Value</h2>
<p>While writing rules for Rector or PHPStan, we need to know the exact values of the argument. E.g., here we want to get <code>100</code>.</p>
<pre><code class="language-php">$someMethod-&gt;someCall(100);</code></pre>
<p>How can we get the 1st argument value of our method call with plain php-parser?</p>
<pre><code class="language-php">use PhpParser\Node\Expr\MethodCall;
use PhpParser\Node\Scalar\LNumber;
use PhpParser\Node\Scalar\String_;
use PHPStan\Node\Constant\ClassConstantFetch;

final class SomeRule
{
    public function resolveFirstArgumentValue(MethodCall $methodCall)
    {
        if (count($methodCall-&gt;args) &lt; 1) {
            return null;
        }

        $firstArgValue = $methodCall-&gt;args[0]-&gt;value;
        if ($firstArgValue instanceof LNumber) {
            return $firstArgValue-&gt;value;
        }

        if ($firstArgValue instanceof String_) {
            return $firstArgValue-&gt;value;
        }

        if ($firstArgValue instanceof ClassConstantFetch) {
            // ..
        }

        // ...
    }
}</code></pre>
<p>You get the idea. We have to also account for non-direct known values like these:</p>
<pre><code class="language-php">private const LIMIT = 100;

$someMethod-&gt;someCall(self::LIMIT);</code></pre>
<p><strong>How does Astral help here?</strong></p>
<pre><code class="language-php">use PhpParser\Node\Expr\MethodCall;
use Symplify\Astral\NodeValue\NodeValueResolver;

final class SomeRule
{
    public function __construct(
        private NodeValueResolver $nodeValueResolver
    ) {

    }
    public function resolveFirstArgumentValue(MethodCall $methodCall)
    {
        if (count($methodCall-&gt;args) &lt; 1) {
            return null;
        }

        $firstArgValue = $methodCall-&gt;args[0]-&gt;value;
        // the 2nd argument is current file path, so Astral can resolve magical constants like __DIR__
        // it is available in both Rector/PHPStan via $scope-&gt;getFile()
        return $this-&gt;nodeValueResolver-&gt;resolve($firstArgValue, __FILE__);
    }
}</code></pre>
<p>Straightforward and simple. The <code>NodeValueResolver</code> can deal with constant references to another class, with magical <code>__DIR__</code> or with <code>SomeClass::class</code> references.</p>
<h2 id="3-Change-the-Node">3. Change the Node</h2>
<p>Now we put all three parts together to demonstrate the real power of Astral. <strong>We already know that simple operations in AST are very hard to write</strong>. AST is a low-level language that has to account for various errors.</p>
<p>How to change node in pure php-parser? It's a topic so extensive it would make a standalone post. Fortunately, there is one. I wrote <a href="/blog/2017/11/06/how-to-change-php-code-with-abstract-syntax-tree/">How to change PHP code with Abstract Syntax Tree</a> 3 years ago. Beware, it's a lot of code simple method rename.</p>
<p><br></p>
<p>Here we'll use the handy Astral service <code>SimpleCallableNodeTraverser</code>. It's typical to be used in Rector rules, where we need to traverse deeper into nodes.</p>
<p><strong>Enough theory, let the code talk:</strong></p>
<pre><code class="language-php">use PhpParser\Node;
use PhpParser\Node\Expr\MethodCall;
use PhpParser\Node\Scalar\LNumber;
use PhpParser\Node\Stmt\Class_;
use Symplify\Astral\Naming\SimpleNameResolver;
use Symplify\Astral\NodeTraverser\SimpleCallableNodeTraverser;
use Symplify\Astral\NodeValue\NodeValueResolver;

final class SomeRule
{
    public function __construct(
        private NodeValueResolver $nodeValueResolver,
        private SimpleNameResolver $simpleNameResolver,
        private SimpleCallableNodeTraverser $simpleCallableNodeTraverser,
    ) {
    }

    // here we traverse class, and we want to process method calls inside it
    public function process(Class_ $class)
    {
        $this-&gt;simpleCallableNodeTraverser-&gt;traverseNodesWithCallable($class, function (Node $node) {
            if (! $node instanceof MethodCall) {
                return null;
            }

            return $this-&gt;processMethodCall($node);
        });
    }

    private function processMethodCall(MethodCall $methodCall): ?Node
    {
        // with early return techinque, we skip all the nodes that does not match our needs
        if (! $this-&gt;simpleNameResolver-&gt;isName($methodCall-&gt;name, 'someCall')) {
            return null;
        }

        // we need at least 1 argument
        if (! count($methodCall-&gt;args) &lt; 1) {
            return null;
        }

        $argValue = $methodCall-&gt;args[0]-&gt;value;
        $value = $this-&gt;nodeValueResolver-&gt;resolve($argValue, __FILE__);
        if (! is_int($value)) {
            return null;
        }

        // is the value lower than 50? skip it
        if ($value &lt;= 50) {
            return null;
        }

        // replaced with 100
        $methodCall-&gt;args[0]-&gt;value = new LNumber(100);
        return $methodCall;
    }
}</code></pre>
<p>That's it!</p>
<p><br></p>
<h2 id="Rule-of-the-Thumb">Rule of the Thumb</h2>
<p>Too much to absorb? I agree. Let's keep it simple - the most useful service is <code>SimpleNameResolver</code>. Try it next time you'll be writing the Rector rule, PHPStan rule, or extension. You'll be surprised how much boilerplate code you can save. Your code will be cleaner and easier to read.</p>
<p>There is a couple of Astral features we haven't check yet. They're all in <a href="https://github.com/symplify/astral">README</a>.</p>
<p><br></p>
<p>Happy coding!</p>

            <br>


            <div class="card mt-5 border-warning">
                <div class="card-body text-center mt-2">
                    <p>
                        Have you find this post useful? <strong>Do you want more?</strong>
                    </p>
                    <p>
                        Follow me on <a href="https://twitter.com/votrubaT">Twitter</a>, <a href="/rss.xml">RSS</a> or support me on <a href="https://github.com/sponsors/TomasVotruba">GitHub Sponsors</a>.
                    </p>
                </div>
            </div>

            <div class="card mt-4">
                <div class="card-body text-white bg-success text-center">
                                            <a href="/blog/never-forget-symfony-config-options-again" class="d-block">
                            <div>
                                Read next → <strong>Never Forget Symfony Config Options Again</strong>
                            </div>
                        </a>
                                    </div>
            </div>

            <br>
            <br>

            <a name="comments"></a>
            <div id="disqus_thread"></div>

<script>
    /**
     *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
     *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/
    /*
    var disqus_config = function () {
    this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
    this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
    };
    */
    (function() { // DON'T EDIT BELOW THIS LINE
        var d = document, s = d.createElement('script');
        s.src = 'https://itsworthsharing.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
        </div>

        <script id="dsq-count-scr" src="https://itsworthsharing.disqus.com/count.js" async defer></script>

        <link href="/assets/prism/prism.css" rel="stylesheet" type="text/css" />
        <script src="/assets/prism/prism.js"></script>

        <script>
    ga=function(){ ga.q.push(arguments) };
    ga.q=[];
    ga.l=+new Date;
    ga('create', 'UA-46082345-1', 'auto');
    ga('send','pageview');
</script>
<script src="https://www.google-analytics.com/analytics.js" async defer></script>

        <script type="text/javascript">
            // @see https://stackoverflow.com/a/30776817/1348344
            var date = new Date();
            // display every 2nd hour, not to spam users
            if (date.getHours() % 2 === 1) {
                document.querySelector('.book-banner').style.display = 'visible';
            } else {
                document.querySelector('.book-banner').style.display = 'none';
            }
        </script>
    </body>
</html>
